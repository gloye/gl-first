# 第二章笔记

## 调用点与调用栈

首先提到了调用点（Call-site）与调用栈（Call-stack）的概念，顺便提到了如何`debugger`查看栈信息。

## `this`的绑定规则

- 决定在函数执行期间`this`的指向，四种绑定规则

### 默认绑定(Default Binding)

```javascript

function foo() {
    console.log(this.a);
}

var a = 2;

foo(); // 2

```

默认绑定一般指向全局对象，浏览器下为window。

### 隐含绑定(Implicit Binding)

```javascript

function foo() {
    console.log(this.a);
}

var obj = {
    a: 2,
    foo: foo
};

obj.foo(); // 2

```

就是`foo()`作为引用属性添加到`obj`上，这一段描述在原文也是比较晦涩的。

>首先，注意 foo() 被声明然后作为引用属性添加到 obj 上的方式。无论 foo() 是否一开始就在 obj 上被声明，还是后来作为引用添加（如上面代码所示），这个 函数 都不被 obj 所真正“拥有”或“包含”。  
然而，调用点 使用 obj 环境来 引用 函数，所以你 可以说 obj 对象在函数被调用的时间点上“拥有”或“包含”这个 函数引用。  
不论你怎样称呼这个模式，在 foo() 被调用的位置上，它被冠以一个指向 obj 的对象引用。当一个方法引用存在一个环境对象时，隐含绑定 规则会说：是这个对象应当被用于这个函数调用的 this 绑定。  
因为 obj 是 foo() 调用的 this，所以 this.a 就是 obj.a 的同义词

我在这里解释为，`foo()`调用了`obj`作为`this`，`this.a`等同于`obj.a`，隐性绑定中我们知道调用了哪个`obj`作为`this`，就可以了。

隐形绑定这里还提到了一个隐含丢失的问题。

#### 隐含丢失(Implicitly Lost)

> `this`绑定最常让人沮丧的事情之一，就是当一个**隐含绑定**丢失了它的绑定，这通常意味着它会退回到**默认绑定**

```javascript

function foo() {
    console.log(this.a);
}

var obj = {
    a: 2,
    foo: foo
};

var bar = obj.foo; // 函数引用！

var a = "oops, global"; // `a` 也是一个全局对象的属性

bar(); // "oops, global"

```

这里为什么会丢失，表面上不难看出，我们定义了一个新的变量`bar`并赋值`obj.foo`给他，实际上，我们只给了`bar`一个对于`foo()`的引用。这里最开始容易有一个误解，就是`bar`本身没有`a`的属性，如果我们给`bar.a=3`然后去执行`bar()`会得到正确的结果，然而实际上，我们可以通过代码来验证:

```javascript

var cus = foo;
console.log(bar === cus) //true;

```

当我们传递一个回调函数时，也会发生这种情况：

```javascript

 function foo() {
     console.log(this.a);
 }

 function doFoo(fn) {
     fn(); // <-- 调用点!
 }

 var obj = {
     a: 2,
     foo: foo
 };

 var a = "oops, global"; // `a` 也是一个全局对象的属性

 doFoo(obj.foo); // "oops, global"

```

这个实际上和上边的是一样的--，我们只是把`obj`的引用`foo`传过去了，这里可以联动一下《高程》的第四章参数传递

传递回调的函数是语言内建的也一样：

```javascript

function foo() {
    console.log(this.a);
}

var obj = {
    a: 2,
    foo: foo
};

var a = "oops, global"; // `a` 也是一个全局对象的属性

setTimeout(obj.foo, 100); // "oops, global"

```

> 把这个粗糙的，理论上的 setTimeout() 假想实现当做 JavaScript 环境内建的实现的话：

```javascript

function setTimeout(fn, delay) {
    // （通过某种方法）等待 `delay` 毫秒
    fn(); // <-- 调用点!
}

```

### 明确绑定(Explicit Binding)

简单来讲就是使用`call(...)`或者`apply(...)`方法指定你的`this`，至于`call`和`apply`的区别可以查看MDN文档

>如果你传递一个简单基本类型值（string，boolean，或 number 类型）作为 this 绑定，那么这个基本类型值会被包装在它的对象类型中（分别是 new String(..)，new Boolean(..)，或 new Number(..)）。这通常称为“封箱（boxing）”。