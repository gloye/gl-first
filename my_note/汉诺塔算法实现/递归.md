# 从一个游戏去理解递归

递归是一种强大的编程技术，递归函数就是会直接或者间接地调用自身的一种函数，举个例子，我们开始成语接龙，我先开始，为所欲为。当然这只是一个小段子，在介绍递归的时候，《javascript语言精粹》一书中介绍了这样一种游戏——汉诺塔。下面我们从这个游戏开始去理解其中的意义。在书中提到，递归就是把一个问题分割成一组相似的子问题，每一个问题都用一个寻常解去解决，而一个递归函数，是调用自身去解决它的子问题，那么我们来看一下汉诺塔这款游戏。
游戏规则介绍:
汉诺塔：汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。
简而言之，一个三层的汉诺塔模型的规则需要符合：

  1. 从A挪到C
  2. 一次只能挪一块
  3. 小块始终在大块上面

那么，这个问题可以拆分为

  1. 我们把最大的一块从A挪到C上（最大的只能在最下面）
  2. 我们把其余的从A挪到B上 （最大块是最后离开A的，上一步完成后，其余块应在B上）
  3. 我们把其余的从B挪到C上 （最大块到C上已经可以保持不动了，次大块此时成为最大块）

所以说，这个问题实际上就是，反复执行把最大块挪到指定位置的一个函数的递归。下面看一下代码

```js
 var hanoi = function(num, A, B, C) {
      if (num > 0) {
        hanoi(num - 1, A, C, B);
        console.log(num + A + " to " + C)
        hanoi(num - 1, B, A, C);
      }
    }
    hanoi(3, "开始位置", "中转位置", "目标位置")
```

函数很简单，代码并不多，但是由于在函数内部调用自身两次，所以单看代码很难明白，我们来
逐一分析其中的原理。

## 分析

这个函数的除了数字的三个变量分别代表，开始柱子，中间柱子，目标柱子

## 执行步骤

1. 把最小的（目前在A）挪到C上，然后B就是目标柱子 // A C B
2. 把中间的（目前在A）挪到B上，然后C就是目标柱子 // A B C
3. 把最小的（目前在C）挪到B上，然后A就是目标柱子 // C B A
4. 把最大的（目前在A）挪到C上，然后B就是目标柱子 // A C B
5. 把最小的（目前在B）挪到A上，然后B就是目标柱子 // B A B
6. 把中间的（目前在B）挪到C上，然后A就是目标柱子 // B C A
7. 把最小的（目前在A）挪到C上，完成             // A C B

上面是执行结果，下面我们逐步对函数进行解释，也就是比较笨的"人脑递归"。

## 递归步骤

先执行，后输出 （只执行执行步骤前面的函数）

1. hanoi(3, "开始", "中转", "目标")
2. hanoi(2, "开始", "目标", "中转")
3. hanoi(1, "开始", "中转", "目标")
4. 1——>开始——>目标
5. 2——>开始——>中转
6. 3——>开始——>目标

先输出，后执行  （只执行执行步骤后面的函数）

1. 3 开始 目标  hanoi(2,"中转","开始","目标")
2. 2 中转 目标  hanoi(1,"开始","中转","目标")
3. 1 开始 目标  hanoi(1,"开始","中转","目标")

上面两部分没有什么实际意义，只是让你熟悉下递归的流程是怎样的，下面是组合起来后

### 组合起来

1. hanoi(3, "开始", "中转", "目标")
2. hanoi(2, "开始", "目标", "中转")
3. hanoi(1, "开始", "中转", "目标")
4. 1——>开始——>目标
5. 2——>开始——>中转 （回到A2里面）
6. hanoi(1, "目标", "开始", "中转") （执行B1）
7. 1——>目标——>中转
8. hanoi(3, "开始", "中转", "目标") （回到A3里面）
9. 3——>开始——>目标
    ---------------噩梦分割线------------------------- 
10. hanoi(2, "中转", "开始", "目标") （执行B2）
11. hanoi(1, "中转", "目标"，"开始") （执行A1）
12. 1——>中转——>开始
13. 2——>中转——>目标
14. hanoi(1,"开始","中转","目标”)（执性B1）
15. 1——>开始——>"目标"

好的，三层的汉诺塔已经让我的人脑爆栈了，总结一下，递归函数就是假设在函数内部调用自己，只要符合条件，它就一直调用下去，直到无法调用才去执行下一步。就像上面写得那样，当执行时，如果num>1，它会一直执行function(num-1),类似于循环while(i>0){i--}；然后去执行function(1){console...},返回到function(2){console... function(2-1){后执行的函数,这里也有调用自己的情况}}就是这样。